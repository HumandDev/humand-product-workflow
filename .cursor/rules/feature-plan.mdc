---
description: When the user asks to plan a feature, assess feasibility, or estimate complexity for a feature across Humand repos
globs: 
alwaysApply: false
---

You are helping a product manager plan a feature. Your task is to explore the codebase via GitHub API (no local clones needed), assess technical feasibility, estimate relative complexity, and produce a **practical, PM-ready** output that helps finalize requirements efficiently.

**Do NOT produce an implementation plan** (no task breakdown by developer role, no step-by-step build instructions) unless the user explicitly asks for it.

## Prerequisites

- `gh` CLI installed and authenticated (`gh auth login`)
- Read access to the HumandDev GitHub organization

Verify access before starting:
```bash
gh api repos/HumandDev/humand-main-api --jq '.full_name'
```
If this fails, stop and help the user authenticate.

## Repository Registry

| Repo | GitHub | Default Branch | Tech Stack | Role |
|------|--------|----------------|------------|------|
| humand-main-api | `HumandDev/humand-main-api` | `develop` | Node.js/TypeScript, Express, Sequelize, NX monorepo | Backend |
| material-hu | `HumandDev/material-hu` | `main` | React, TypeScript, MUI-based component library | Frontend (shared) |
| humand-web | `HumandDev/humand-web` | `develop` | React, TypeScript, Vite, React Query, Biome | Frontend (web) |
| humand-backoffice | `HumandDev/humand-backoffice` | `develop` | React, TypeScript, Vite, Biome | Frontend (admin) |
| humand-mobile | `HumandDev/humand-mobile` | `develop` | React Native, TypeScript, Redux | Mobile |
| hu-translations | `HumandDev/hu-translations` | `main` | JSON i18n files, 18 locales | Translations |

### Dependency Order (upstream first)

1. humand-main-api (no dependencies)
2. material-hu (no dependencies; web/backoffice/mobile depend on it)
3. humand-web (depends on material-hu, humand-main-api)
4. humand-backoffice (depends on material-hu, humand-main-api)
5. humand-mobile (depends on material-hu, humand-main-api)
6. hu-translations (referenced by web/backoffice/mobile)

### Known Structural Patterns

Use these as starting points when exploring. Do NOT assume they are exhaustive -- always verify against the actual tree.

**humand-main-api:**
- Modules: `humand-packages/monolith/src/api/modules/<module>/` (each has `business/`, `infrastructure/`, `presentation/`)
- Route registration: `humand-packages/monolith/src/api/routes/root.ts` (private and public routers)
- Controllers extend `BaseController`, use `@Service()` decorator (typedi)
- Routers export `start<Name>Router(): Router` functions
- Server nodes: `humand-packages/monolith/src/api/nodes/` (app, backoffice, public, etc.)

**humand-web:**
- Pages: `src/pages/dashboard/<feature>/`
- Services (API calls): `src/services/<feature>.ts` (uses axios instance from `src/config/api.ts`)
- Query hooks: `src/hooks/queryHooks/<feature>.ts` (react-query)
- Feed/homepage: `src/pages/dashboard/feed/Feed.tsx`
- Translations: uses `useLokaliseTranslation` or `useCustomServerTranslation`

**humand-backoffice:**
- Similar structure to humand-web

**humand-mobile:**
- Modules: `app/modules/<module>/` (screens, services, redux, components)
- Services: `app/modules/<module>/services.ts` (uses API instance from `app/config/api/`)
- Home screen: `app/modules/home/index.tsx`
- Navigation: React Navigation
- State: Redux with `@redux/utils`
- Translations: `react-i18next` with `useTranslation`

**hu-translations:**
- Structure: `locale/<lang>/<namespace>.json` (18 locales: bg, da, de, en, es, fi, fr, is, it, no, pl, pt, pt_BR, ro, ru, sv, th, uk)
- Each namespace maps to a feature area (e.g., `home.json`, `post.json`, `group.json`)
- English (`en`) and Spanish (`es`) are the primary languages; others may lag behind

**material-hu:**
- Shared MUI-based React components
- Used by humand-web, humand-backoffice, and humand-mobile

## Workflow

### Step 1: Clarify Scope & Definitions (always; repeat as needed)

Check if the user already provided a feature/fix/change description or Jira ticket ID in their message.

If any requirement is **ambiguous or missing**, ask a small set of **dynamic** clarifying questions tailored to the request, then **pause** and wait for answers **before** continuing to Steps 2–5.

This clarification gate applies **at the start and mid-way** through exploration: if you discover a new unknown later (e.g., while reading code) that would change scope, API contract, data meaning, permissions/visibility, acceptance criteria, or sizing, **stop and ask** instead of guessing.

If a Jira ticket ID is present (pattern `[A-Z]+-\d+`), fetch details via Atlassian MCP:
```
mcp__atlassian__get_issue(issue_id_or_key: "SQRN-1234")
```
If MCP is unavailable, proceed with whatever was provided.

If the user's message lacks sufficient detail, ask in ONE message (only include the items that are actually needed to disambiguate scope):

```
**Feature Planning / Change Request**

Please provide:

1. **Goal / expected behavior** (what changes, for whom):
2. **Where it appears** (web/mobile/backoffice + screen/placement):
3. **Who is affected** (roles/permissions/segmentations/visibility rules):
4. **Key definitions** (anything that changes scope: what counts/qualifies, time windows, states to include/exclude, etc.):
5. **Update expectations** (load-only vs refresh vs realtime):
6. **Jira ticket** (ID, URL, or "none"):
7. **Figma URL** (optional, or "none"):

Example: "SQRN-1234" or "Add a reactions feature to the feed posts"
```

### Step 2: Infer Affected Repos (validation-first)

Based on the feature description, determine which repos are involved. Use these heuristics:

- Feature needs a **new API endpoint or backend logic** → humand-main-api
- Feature has **web UI changes** → humand-web (+ material-hu if new shared components)
- Feature has **admin panel changes** → humand-backoffice (+ material-hu if new shared components)
- Feature has **mobile UI changes** → humand-mobile
- Feature has **user-facing text** → hu-translations
- Feature needs a **new shared component** → material-hu

Present the inferred repos to the PM and ask for confirmation:
```
Based on your description, this feature would involve:
  1. humand-main-api (new endpoint for X)
  2. humand-web (homepage integration)
  3. humand-mobile (homepage integration)
  4. hu-translations (new user-facing strings)

Does this look right? Any repos to add or remove?
```

### Step 3: Explore Codebase via GitHub API (lightweight validation)

For each affected repo, explore the codebase just enough to validate feasibility, data sources, and integration points. **Do not perform a deep implementation dive.**

**Strategy: progressive drill-down, not exhaustive scan.** Aim for **3–8 file reads total**.

**Clarification gate (again):** If exploration reveals a scope-defining unknown (requirements, definitions, permissions, visibility, data meaning, API contract), **pause** and ask the user before proceeding to feasibility/complexity/sizing. Do not silently pick an interpretation.

#### Step 3a: Fetch directory tree (top-level + relevant subtrees)

```bash
# Top-level structure
gh api repos/HumandDev/<repo>/git/trees/<default_branch> --jq '.tree[].path'

# Drill into relevant directories (based on Known Structural Patterns above)
gh api "repos/HumandDev/<repo>/git/trees/<default_branch>?recursive=1" \
  --jq '[.tree[] | select(.path | test("<relevant_pattern>"))] | .[].path'
```

Keep tree fetches focused. For example, for humand-main-api, filter for `modules/` and `routes/` paths. For humand-web, filter for `src/pages/`, `src/services/`, `src/hooks/`.

#### Step 3b: Read key files (only what validates feasibility)

Read specific files to understand patterns the feature should follow (minimal set):

```bash
gh api repos/HumandDev/<repo>/contents/<file_path>?ref=<branch> \
  --jq '.content' | base64 -d
```

What to read per repo (adapt based on feature):

- **humand-main-api**: A similar existing module's router + controller (e.g., `appRatings`), and `routes/root.ts` for registration pattern
- **humand-web**: The page where the feature will be integrated (e.g., `Feed.tsx`), a similar service file, a similar query hook
- **humand-mobile**: The screen where the feature will be integrated (e.g., `home/index.tsx`), a similar service file
- **hu-translations**: The relevant namespace in `en` (e.g., `locale/en/home.json`) to see existing key naming conventions
- **material-hu**: Existing similar components if new shared components are needed

**Important**: Read only what you need. Aim for 3–8 file reads total. Read the integration point + one reference example per repo.

### Step 4: Assess Feasibility & Complexity (effort-focused)

Based on the exploration, produce:

If critical clarifications are still missing, do **not** provide a definitive feasibility rating or t-shirt size. Instead, state what is blocked and ask the minimum questions needed to unblock.

#### 4a. Technical Feasibility

Rate how well the feature fits the current architecture:

- **Standard extension**: Follows an existing pattern exactly (e.g., adding a new module that mirrors an existing one). Low risk.
- **Moderate adaptation**: Mostly follows existing patterns but requires some novel wiring or minor architectural decisions. Medium risk.
- **Significant new pattern**: Requires patterns not currently in the codebase (e.g., WebSockets when none exist, new database tables with complex relations). Higher risk.

Be specific about what makes it standard or novel. Reference the actual files/patterns you found.

#### 4b. Complexity Signals

Report these concrete signals (do not invent time estimates). If you cannot **prove** a value from code exploration, mark it as **unknown**:

| Signal | Value |
|--------|-------|
| Repos involved | (count and names) |
| Files to create | (known count or "unknown") |
| Files to modify | (known count or "unknown") |
| New patterns required | (list any, or "none") |
| Database changes | (yes/no, describe if yes) |
| Cross-repo data contracts | (count of new API interfaces) |

#### 4c. T-Shirt Size

Based on the signals above, assign a relative size:

- **S**: 1-2 repos, < 5 files, follows existing patterns exactly
- **M**: 2-3 repos, 5-10 files, mostly existing patterns with minor adaptation
- **L**: 3-4 repos, 10-20 files, some new patterns or significant logic
- **XL**: 4+ repos, 20+ files, new architectural patterns, database changes, or high cross-repo coordination

State what drove the sizing.

#### 4d. Risk Flags

Flag anything that increases risk or uncertainty:

- Touches authentication or authorization flows
- Requires database migrations
- Introduces a new external dependency or service
- Modifies shared components that affect multiple consumers
- Requires patterns not yet established in the codebase
- High cross-repo coupling (e.g., strict API contract between 3+ repos)

If no flags, explicitly say "No elevated risks identified."

### Step 5: Produce PM-Ready Output (concise, practical)

Goal: help a PM **finish the requirements** and decide if the change is feasible and what it touches — without turning this into a developer execution plan.

Guidelines:
- Keep it **short** and **decision-oriented**
- Prefer **Yes/No/Unknown** statements over speculation
- If something cannot be proven from code exploration, mark it **unknown**
- Do not list step-by-step tasks or per-role implementation breakdown

Include, when applicable:
- **Backend required?** (yes/no/unknown) and *why*
- **Data contracts** (endpoint(s), method, path, request params, response shape)
- **Visibility/permissions/segmentation implications**
- **Definitions that must be decided** (e.g., "what counts", time window, states)
- **Risks & edge cases** (performance, caching, timezone, correctness)
- **Acceptance criteria draft** (only if it can be stated unambiguously)

### Step 6: Output Summary (single structured answer)

Display the full assessment as a single structured output (no implementation plan):

```
# Feature Plan: <feature name>

## Overview
<1-2 sentence summary of what was requested>

## Affected Repos
<bulleted list with role tags>

## Backend Required?
<yes | no | unknown>
<1-3 bullets why, referencing files/patterns found>

## Key Definitions / Open Questions
<bulleted list; only what is needed to unblock>

## Feasibility
<standard extension | moderate adaptation | significant new pattern>
<explanation>

## Complexity
<T-shirt size with signal table>

## Risk Flags
<list or "none">

## Data Contracts (if any)
<endpoint(s) with request/response shapes>

## Suggested Next Steps
- Confirm definitions above (time windows, states, permissions/visibility, etc.)
- Attach Jira/Figma (if available) and record the agreed contract(s)
- Hand off to devs for implementation once requirements are stable
```

## Error Handling

- If `gh` CLI is not installed or not authenticated: Stop and provide setup instructions
- If a repo is not accessible: Warn and skip that repo, note it in the output
- If a file path from Known Structural Patterns doesn't exist: The codebase may have changed. Adapt by reading the actual tree and noting the discrepancy.
- If the feature description is too vague: Ask clarifying questions before exploring. Do not guess.

## Important Notes

- This rule is **read-only**. It never creates branches, modifies code, or writes to any repo.
- All codebase exploration happens via `gh api` -- no local clones required.
- The plan is a best-effort technical assessment. Developers should validate the plan against their knowledge of the codebase before starting.
- The Known Structural Patterns section should be updated if the repos undergo significant architectural changes.
- When a Jira ticket is provided, include the ticket URL in the output: `https://humand.atlassian.net/browse/<TICKET>`
