---
description: When the user asks to plan a feature, assess feasibility, estimate complexity, or produce an implementation plan for a feature across Humand repos
globs: 
alwaysApply: false
---

You are helping a product manager plan a feature. Your task is to explore the codebase via GitHub API (no local clones needed), assess technical feasibility, estimate relative complexity, and produce an implementation plan broken down by developer role.

## Prerequisites

- `gh` CLI installed and authenticated (`gh auth login`)
- Read access to the HumandDev GitHub organization

Verify access before starting:
```bash
gh api repos/HumandDev/humand-main-api --jq '.full_name'
```
If this fails, stop and help the user authenticate.

## Repository Registry

| Repo | GitHub | Default Branch | Tech Stack | Role |
|------|--------|----------------|------------|------|
| humand-main-api | `HumandDev/humand-main-api` | `develop` | Node.js/TypeScript, Express, Sequelize, NX monorepo | Backend |
| material-hu | `HumandDev/material-hu` | `main` | React, TypeScript, MUI-based component library | Frontend (shared) |
| humand-web | `HumandDev/humand-web` | `develop` | React, TypeScript, Vite, React Query, Biome | Frontend (web) |
| humand-backoffice | `HumandDev/humand-backoffice` | `develop` | React, TypeScript, Vite, Biome | Frontend (admin) |
| humand-mobile | `HumandDev/humand-mobile` | `develop` | React Native, TypeScript, Redux | Mobile |
| hu-translations | `HumandDev/hu-translations` | `main` | JSON i18n files, 18 locales | Translations |

### Dependency Order (upstream first)

1. humand-main-api (no dependencies)
2. material-hu (no dependencies; web/backoffice/mobile depend on it)
3. humand-web (depends on material-hu, humand-main-api)
4. humand-backoffice (depends on material-hu, humand-main-api)
5. humand-mobile (depends on material-hu, humand-main-api)
6. hu-translations (referenced by web/backoffice/mobile)

### Known Structural Patterns

Use these as starting points when exploring. Do NOT assume they are exhaustive -- always verify against the actual tree.

**humand-main-api:**
- Modules: `humand-packages/monolith/src/api/modules/<module>/` (each has `business/`, `infrastructure/`, `presentation/`)
- Route registration: `humand-packages/monolith/src/api/routes/root.ts` (private and public routers)
- Controllers extend `BaseController`, use `@Service()` decorator (typedi)
- Routers export `start<Name>Router(): Router` functions
- Server nodes: `humand-packages/monolith/src/api/nodes/` (app, backoffice, public, etc.)

**humand-web:**
- Pages: `src/pages/dashboard/<feature>/`
- Services (API calls): `src/services/<feature>.ts` (uses axios instance from `src/config/api.ts`)
- Query hooks: `src/hooks/queryHooks/<feature>.ts` (react-query)
- Feed/homepage: `src/pages/dashboard/feed/Feed.tsx`
- Translations: uses `useLokaliseTranslation` or `useCustomServerTranslation`

**humand-backoffice:**
- Similar structure to humand-web

**humand-mobile:**
- Modules: `app/modules/<module>/` (screens, services, redux, components)
- Services: `app/modules/<module>/services.ts` (uses API instance from `app/config/api/`)
- Home screen: `app/modules/home/index.tsx`
- Navigation: React Navigation
- State: Redux with `@redux/utils`
- Translations: `react-i18next` with `useTranslation`

**hu-translations:**
- Structure: `locale/<lang>/<namespace>.json` (18 locales: bg, da, de, en, es, fi, fr, is, it, no, pl, pt, pt_BR, ro, ru, sv, th, uk)
- Each namespace maps to a feature area (e.g., `home.json`, `post.json`, `group.json`)
- English (`en`) and Spanish (`es`) are the primary languages; others may lag behind

**material-hu:**
- Shared MUI-based React components
- Used by humand-web, humand-backoffice, and humand-mobile

## Workflow

### Step 1: Gather Feature Description **and Key Definitions (early)**

Check if the user already provided a feature description or Jira ticket ID in their message.

**Always ask key definition questions up front** (even if a Jira ticket exists) when the feature involves time windows, visibility, or counting. Use general questions only; if none apply, omit them entirely. These are required to validate feasibility and effort before deep exploration:

- What is the **time window** and **timezone** definition (if any)?
- What are the **inclusion/exclusion rules** and the **source of truth** for visibility?
- What is the **expected output format** (and empty/zero-state behavior)?
- What are the **refresh/recency requirements** (manual, periodic, event-driven)?

If these are already answered, summarize them explicitly before continuing.

If a Jira ticket ID is present (pattern `[A-Z]+-\d+`), fetch details via Atlassian MCP:
```
mcp__atlassian__get_issue(issue_id_or_key: "SQRN-1234")
```
If MCP is unavailable, proceed with whatever was provided.

If the user's message lacks sufficient detail, ask in ONE message:

```
**Feature Planning**

Please provide:

1. **Feature description** (natural language -- this is the primary input):
2. **Jira ticket** (ID, URL, or "none"):
3. **Figma URL** (optional, or "none"):

Example: "SQRN-1234" or "Add a reactions feature to the feed posts"
```

### Step 2: Infer Affected Repos (validation-first)

Based on the feature description, determine which repos are involved. Use these heuristics:

- Feature needs a **new API endpoint or backend logic** → humand-main-api
- Feature has **web UI changes** → humand-web (+ material-hu if new shared components)
- Feature has **admin panel changes** → humand-backoffice (+ material-hu if new shared components)
- Feature has **mobile UI changes** → humand-mobile
- Feature has **user-facing text** → hu-translations
- Feature needs a **new shared component** → material-hu

Present the inferred repos to the PM and ask for confirmation:
```
Based on your description, this feature would involve:
  1. humand-main-api (new endpoint for X)
  2. humand-web (homepage integration)
  3. humand-mobile (homepage integration)
  4. hu-translations (new user-facing strings)

Does this look right? Any repos to add or remove?
```

### Step 3: Explore Codebase via GitHub API (lightweight validation)

For each affected repo, explore the codebase just enough to validate feasibility, data sources, and integration points. **Do not perform a deep implementation dive.**

**Strategy: progressive drill-down, not exhaustive scan.** Aim for **3–8 file reads total**.

#### Step 3a: Fetch directory tree (top-level + relevant subtrees)

```bash
# Top-level structure
gh api repos/HumandDev/<repo>/git/trees/<default_branch> --jq '.tree[].path'

# Drill into relevant directories (based on Known Structural Patterns above)
gh api "repos/HumandDev/<repo>/git/trees/<default_branch>?recursive=1" \
  --jq '[.tree[] | select(.path | test("<relevant_pattern>"))] | .[].path'
```

Keep tree fetches focused. For example, for humand-main-api, filter for `modules/` and `routes/` paths. For humand-web, filter for `src/pages/`, `src/services/`, `src/hooks/`.

#### Step 3b: Read key files (only what validates feasibility)

Read specific files to understand patterns the feature should follow (minimal set):

```bash
gh api repos/HumandDev/<repo>/contents/<file_path>?ref=<branch> \
  --jq '.content' | base64 -d
```

What to read per repo (adapt based on feature):

- **humand-main-api**: A similar existing module's router + controller (e.g., `appRatings`), and `routes/root.ts` for registration pattern
- **humand-web**: The page where the feature will be integrated (e.g., `Feed.tsx`), a similar service file, a similar query hook
- **humand-mobile**: The screen where the feature will be integrated (e.g., `home/index.tsx`), a similar service file
- **hu-translations**: The relevant namespace in `en` (e.g., `locale/en/home.json`) to see existing key naming conventions
- **material-hu**: Existing similar components if new shared components are needed

**Important**: Read only what you need. Aim for 3–8 file reads total. Read the integration point + one reference example per repo.

### Step 4: Assess Feasibility & Complexity (effort-focused)

Based on the exploration, produce:

#### 4a. Technical Feasibility

Rate how well the feature fits the current architecture:

- **Standard extension**: Follows an existing pattern exactly (e.g., adding a new module that mirrors an existing one). Low risk.
- **Moderate adaptation**: Mostly follows existing patterns but requires some novel wiring or minor architectural decisions. Medium risk.
- **Significant new pattern**: Requires patterns not currently in the codebase (e.g., WebSockets when none exist, new database tables with complex relations). Higher risk.

Be specific about what makes it standard or novel. Reference the actual files/patterns you found.

#### 4b. Complexity Signals

Report these concrete signals (do not invent time estimates). If you cannot **prove** a value from code exploration, mark it as **unknown**:

| Signal | Value |
|--------|-------|
| Repos involved | (count and names) |
| Files to create | (known count or "unknown") |
| Files to modify | (known count or "unknown") |
| New patterns required | (list any, or "none") |
| Database changes | (yes/no, describe if yes) |
| Cross-repo data contracts | (count of new API interfaces) |

#### 4c. T-Shirt Size

Based on the signals above, assign a relative size:

- **S**: 1-2 repos, < 5 files, follows existing patterns exactly
- **M**: 2-3 repos, 5-10 files, mostly existing patterns with minor adaptation
- **L**: 3-4 repos, 10-20 files, some new patterns or significant logic
- **XL**: 4+ repos, 20+ files, new architectural patterns, database changes, or high cross-repo coordination

State what drove the sizing.

#### 4d. Risk Flags

Flag anything that increases risk or uncertainty:

- Touches authentication or authorization flows
- Requires database migrations
- Introduces a new external dependency or service
- Modifies shared components that affect multiple consumers
- Requires patterns not yet established in the codebase
- High cross-repo coupling (e.g., strict API contract between 3+ repos)

If no flags, explicitly say "No elevated risks identified."

### Step 5: Produce Execution Plan (high-level, not deep implementation)

Structure the plan by developer role. For each role, list:

- **Repo**: which repo to work in
- **Summary**: one-line description of what this role does
- **Tasks**: 3–6 high-level tasks focused on validation and effort
  - Avoid file-by-file lists unless the user explicitly asks
  - Reference at most **one** existing pattern/file per role (if needed)
- **Depends on**: which other roles must complete first (if any)

#### Format (generic):

```
## Implementation Plan

### Backend (humand-main-api)
Summary: <one line>
Depends on: none

1. Validate data source(s) and access/visibility rules
2. Define or extend API contract (inputs/outputs)
3. Implement logic + error handling
4. Add minimal tests or metrics (if applicable)

### Frontend - Web (humand-web)
Summary: <one line>
Depends on: Backend (if API changes), Translations

1. Integrate data fetch and caching strategy
2. Implement UI changes per UX definitions
3. Handle error/loading/empty states

### Mobile (humand-mobile)
Summary: <one line>
Depends on: Backend (if API changes), Translations

1. Integrate data fetch and caching strategy
2. Implement UI changes per UX definitions
3. Handle error/loading/empty states

### Translations (hu-translations)
Summary: <one line>
Depends on: none

1. Add new keys in the relevant namespace(s) and propagate to other locales

### Data Contracts

<endpoint>:
  Method: GET/POST
  Path: /<path>
  Response: { field: type, ... }
```

### Step 6: Output Summary

Display the full assessment as a single structured output:

```
# Feature Plan: <feature name>

## Overview
<1-2 sentence summary of what was requested>

## Affected Repos
<bulleted list with role tags>

## Feasibility
<standard extension | moderate adaptation | significant new pattern>
<explanation>

## Complexity
<T-shirt size with signal table>

## Risk Flags
<list or "none">

## Implementation Plan
<per-role breakdown as above>

## Suggested Next Steps
- Share this plan with the development team
- Create Jira subtasks per role (Backend, Frontend, Mobile, Translations)
- Developer runs /start to create branches across repos
```

## Error Handling

- If `gh` CLI is not installed or not authenticated: Stop and provide setup instructions
- If a repo is not accessible: Warn and skip that repo, note it in the output
- If a file path from Known Structural Patterns doesn't exist: The codebase may have changed. Adapt by reading the actual tree and noting the discrepancy.
- If the feature description is too vague: Ask clarifying questions before exploring. Do not guess.

## Important Notes

- This rule is **read-only**. It never creates branches, modifies code, or writes to any repo.
- All codebase exploration happens via `gh api` -- no local clones required.
- The plan is a best-effort technical assessment. Developers should validate the plan against their knowledge of the codebase before starting.
- The Known Structural Patterns section should be updated if the repos undergo significant architectural changes.
- When a Jira ticket is provided, include the ticket URL in the output: `https://humand.atlassian.net/browse/<TICKET>`
